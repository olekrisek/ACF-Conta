Package ContaIntegration "Integrations to the Conta API"; 
/**
 * Retrieves the base URL for the Conta service.
 *
 * @param bool production Specifies whether to retrieve the production or development URL.
 *                         Pass `true` for the production environment, `false` for development.
 *
 * @return string The base URL for the specified environment.
 */
function getContaBaseURL (bool production)
	if ( production ) then
		return "https://api.gateway.conta.no"; 
	else
		return "https://api.gateway.conta-sandbox.no"; 
	end if
end


/**
 * Retrieves the organization ID for a specified organization name in the Conta service.
 *
 * @param string APIkey      The API key for authentication with the Conta service.
 * @param bool   production  Specifies whether to use the production or development environment.
 *                            Pass `true` for production, `false` for development.
 * @param string orgName     The name of the organization for which to retrieve the ID.
 *
 * @return string The organization ID associated with the specified organization name.
 */
function getContaOrganizationID ( string APIkey, bool production, string orgName )
	$$ContaApiKey = APIkey; 
	string hdr = 'apiKey:'+APIkey; 
	string url = getContaBaseURL(production)+"/invoice/organizations";
	string result, compName;
	string gCompID, s,name ; 
	// Do the API call
	result = HTTP_GET(url, hdr);
	// Handle the result, a JSON object
	// print result; 
	JSON res; 
	// Our JSON implementation likes better to have the array in a tag
	// might be improved in a later plugin release. 
	res = '{"a":'+result+'}';
	// loop the result to find matching name
	int i, j= sizeof ( res["a"]);
	for (i=1, j)
		s = format ("a[%d].", i);	// a[1].
		name = res[s+"name"]; // a[1].name
		if ( upper(orgName) == upper(name)) then
			gCompID = res[s+"id"];
			$$ContaCompID = gCompID; 
			$$ContaCompName = res[s+"name"]; 
			break; // We found it, break out of the loop
		end if
	end for
	return gCompID;
end

/**
 * Searches for a specified key in an array of strings.
 *
 * @param string[] arr The array of strings to search through.
 * @param string   key The key to find within the array.
 *
 * @return int The index of the key if found; otherwise, returns -1.
 */
function find_in_array ( array string arr, string key)
	int i; 
	for ( i = 1, sizeof(arr))
		if ( arr[i] == key) then
			return i; 
		end if
	end for
	return -1; 
end
	
/**
 * Calculates the discount amount based on quantity, price, and discount type.
 *
 * @param float  qty   The quantity of items.
 * @param float  price The price per item.
 * @param string disc  The discount to apply. This can be a fixed numeric discount 
 *                      or a percentage discount if it includes a '%' symbol 
 *                      (e.g., '10' for a $10 discount or '15%' for a 15% discount).
 *
 * @return float The total discount amount calculated based on the specified quantity, price, and discount.
 */
Function DiscountCalc ( float qty, float price, string disc)
	disc = trimboth (disc); 
	float discAm, discper; 
	if ( right( disc,1) == "%") then
		discper = float(substring(disc,0, length(disc)-1))/100.0; 
		discAm = qty*price*discper;
	else
		discAm = float(disc);
	end if
	return discAm; 
end

/**
 * Asserts that two strings are equal and throws an exception with a message if they are not.
 *
 * @param string s1      The first string to compare.
 * @param string s2      The second string to compare.
 * @param string message The message to include in the exception if the assertion fails.
 *
 * @throws Exception if the strings are not equal. Including the message in the exception. 
 *
 * @return bool Returns `true` if the strings are equal.
 */
function Assert ( String s1, string s2, string message )
	if ( s1 != s2 ) then
		throw (message); 
	end if
	return true; 
end
/**
 * Asserts that a specified string is found within an array of strings and throws an exception with a message if it is not.
 *
 * @param string   value   The string value to search for in the array.
 * @param string[] arr     The array of strings to search within.
 * @param string   message The message to include in the exception if the assertion fails.
 *
 * @throws Exception if the specified value is not found in the array. Including the message in the exception. 
 *
 * @return bool Returns `true` if the value is found in the array.
 */
function AssertInArray ( string value, array string arr, string message )
	int x = find_in_array (arr, value); 
	if (x<0) then
		throw (message);
	end if
	return true; 
end

/**
 * Retrieves API credentials and related information from the database and returns it as a JSON object.
 *
 * @return JSON A JSON object containing:
 *              - `"APIkey"`: The current Conta API key (string).
 *              - `"CompNo"`: The current Conta organization number (int).
 *              - `"Production"`: `true` if in production mode, otherwise `false` (bool).
 *              - `"EmailSubject"`: The subject line for email invoices (string).
 *              - `"EmailContent"`: The content for email invoices (string).
 *
 *              If no data is found, returns a JSON object with default values:
 *              - `"APIkey"`: an empty string.
 *              - `"CompNo"`: `0`.
 *              - `"Production"`: `false`.
 *              - `"EmailSubject"`: an empty string.
 *              - `"EmailContent"`: an empty string.
 */
function getContaApiKeyandNumber ()
	array string apikeys, prod, invoSub, invoCont; 
	array int contaOrgNr; 
	JSON retObj; 
	
	
	string sql = "SELECT ContaCurrentApiKey, ContaCurrentCompNo, ContaProduction, EmailInvoiceSubject, EmailInvoiceContent FROM Preferences
	
	INTO :apikeys, :contaOrgNr, :prod, :invoSub, :invoCont"; 
	string res = ExecuteSQL(sql); 
	if ( sizeof (apikeys)>0) then
		retObj = JSON ( "APIkey", apikeys[1], "CompNo", contaOrgNr[1], "Production", trimboth(prod[1])=="Yes", 
		"EmailSubject", invoSub[1], "EmailContent", invoCont[1]); 
	else
		retObj = JSON ( "APIkey", "", "CompNo", 0, "Production", false, "EmailSubject", "", "EmailContent", ""); 
	end if
	
	return retObj;
end

/**
 * Creates a JSON object containing the current Conta ID numbers for a record, allowing for later restoration when switching
 * between production and sandbox environments. This function is typically called for each record in the Products, Orders, 
 * and Customers tables.
 *
 * @param int    $ContaID     The current Conta ID for the record (integer).
 * @param string $Notes       Notes associated with this record, typically for context or additional details.
 * @param string $JSONContaIDs The JSON string containing previously saved Conta IDs for easy reference and switching.
 *
 * @return JSON A JSON object structured as follows:
 *              - `"ContaIDsandbox"`: If Sandbox: The current Conta ID number (int).
 *              - `"ContaIDprod"`: If production: The current Conta ID number (int).
 *              
 *
 * This function captures essential IDs for future use, supporting seamless switching between environments.
 */
function CreateContaIDobject ( int ContaID, String Notes, string JSONContaIDs )
	json apiData, returnJson;
	if ( JSONContaIDs != "") then
		returnJson = JSONContaIDs; 
	end if
	print JSONContaIDs + "\nContoaID: " + ContaID + "\n";  
	apiData = getContaApiKeyandNumber(); 
	bool Prod = (apiData["Production"]=="1"); 
	if ( Prod ) then
		print "Production: \n"; 
	  returnJson["ContaIDprod"] = string(ContaID); 
	  if (returnJson["ContaIDsandbox"] == char(63) ) then
		  returnJson["ContaIDsandbox"] = trimboth(Between ( Notes, "Sandbox:", char(13))); 
	  end if
  	else
		print "Sandbox: \n"; 
	  returnJson["ContaIDsandbox"] = string(ContaID); 
	  if (returnJson["ContaIDprod"] == char(63) ) then
		  returnJson["ContaIDprod"] = trimboth(Between ( Notes, "Sharp:", char(13))); 
	  end if
  	end if
	print "returnJson: \n" + string (returnJson)+"\n"+"="*50+"\n"; 
	
	return returnJson; 
end	
/**
 * Creates a JSON object containing the current Conta ID numbers for a record, allowing for later restoration when switching
 * between production and sandbox environments. This function is typically called for each record in the Products, Orders, 
 * and Customers tables.
 *
 * @param int    ContaIDInv     The current Invoice Conta ID for the record (integer).
 * @param int    ContaIDDraft   The current Draft Conta ID for the record (integer).
 * @param string JSONContaIDs The JSON string containing previously saved Conta IDs for easy reference and switching.
 *
 * @return JSON A JSON object structured as follows:
 *              - `"ContaIDsandbox"`: If Sandbox: Object containing "Inv", and "Draft" id numberws
 *              - `"ContaIDprod"`: If production: Object containing "Inv", and "Draft" id numberws
 *              
 *
 * This function captures essential IDs for future use, supporting seamless switching between environments.
 */
function CreateContaIDobjectOrder ( int ContaIDInv, int ContaIDDraft, string JSONContaIDs )
	json apiData, returnJson;
	if ( JSONContaIDs != "") then
		returnJson = JSONContaIDs; 
	end if
	
	apiData = getContaApiKeyandNumber(); 
	bool Prod = (apiData["Production"]=="1"); 
	if ( Prod ) then
	  returnJson["ContaIDprod.Inv"] = string(ContaIDInv); 
	  returnJson["ContaIDprod.Draft"] = string(ContaIDDraft); 
	  
  	else
	  returnJson["ContaIDsandbox.Inv"] = string(ContaIDInv); 
	  returnJson["ContaIDsandbox.Draft"] = string(ContaIDDraft); 
  	end if
	
	return returnJson; 
end	

/**
 * Retrieves the active Conta ID from a saved JSON object based on the module type and current environment setting.
 * This function checks the JSON object for the correct ID to use depending on whether it's for products/customers or 
 * orders (invoiced or draft), and based on whether the environment is production or sandbox.
 *
 * @param string $contaJSONstr The JSON string containing saved Conta IDs for different modules and environments.
 * @param string $module       The module type to determine which ID to retrieve:
 *                             - An empty string (`""`) for Products/Customers.
 *                             - `"OI"` for Orders - Invoiced.
 *                             - `"OD"` for Orders - Draft.
 *
 * @return string The appropriate Conta ID for the module and environment setting. Returns an empty string if:
 *                - `contaJSONstr` is empty.
 *                - The requested Conta ID is not available.
 *
 * @note This function defaults to returning an empty string if the specified key does not exist or if it holds an 
 *       invalid value. It also prints debug information, including input values, selected module, and production 
 *       status.
 *
 * @example Example JSON structure for `contaJSONstr`:
 *          {
 *              "ContaIDprod": "12345",
 *              "ContaIDsandbox": "54321",
 *              "ContaIDprod.Draft": "67890",
 *              "ContaIDsandbox.Draft": "09876",
 *              "ContaIDprod.Inv": "11223",
 *              "ContaIDsandbox.Inv": "33211"
 *          }
 */
function GetActiveContaIDJSON ( string contaJSONstr, string module )
	string ret; 
	if (trimboth(contaJSONstr) == "" ) then
		return ""; 
	end if
	JSON js, apiData; 
	js = contaJSONstr; 
	apiData = getContaApiKeyandNumber(); 
	bool Prod = (apiData["Production"]=="1"); 
	print format ("\nInput: %s\nModule: %s, Prod %d\n", contaJSONstr, module, int(Prod)); 
	case
		:(module == "" && Prod)
			ret = js["ContaIDprod"]; 
		:(module == "" && ! Prod)
			ret = js["ContaIDsandbox"];
		:(module == "OD" && Prod)
			ret = js["ContaIDprod.Draft"];
		:(module == "OI" && Prod)
			ret = js["ContaIDprod.Inv"];
		:(module == "OD" && ! Prod)
			ret = js["ContaIDsandbox.Draft"];
		:(module == "OI" && ! Prod)
			ret = js["ContaIDsandbox.Inv"];
		default
	end case
	print ",    ret="+ret; 
	// If object does not have key, an "?" is returned (char(63))
	if (ret == "0" || ret == char(63)) then
		return ""; 
	end if
	return ret;
end

/**
 * Validates and cleans a given phone number by ensuring it conforms to the Norwegian phone number format.
 * The phone number is stripped of non-numeric characters, and if it contains more than 8 digits, 
 * the country code (+47) is removed. If the resulting number has fewer than 8 digits, it is considered invalid.
 * The function returns a cleaned phone number with exactly 8 digits or an empty string if the number is invalid.
 *
 * @param string $Phone The phone number to validate and clean. It can contain non-numeric characters
 *                      (such as spaces, hyphens, or parentheses) which will be removed.
 *
 * @return string The cleaned phone number, with exactly 8 digits if valid, or an empty string if invalid.
 *
 * @note This function assumes that valid Norwegian phone numbers consist of exactly 8 digits after 
 *       stripping any non-numeric characters. If the number has more than 8 digits, the function strips
 *       the country code (+47) from the front. If the number has fewer than 8 digits after cleaning,
 *       it is considered invalid, and the function returns an empty string.
 *
 * @example
 *          - Input: "+47 123 45 678"
 *            Output: "12345678"
 *          - Input: "123-456-789"
 *            Output: "23456789"
 *          - Input: "123456"
 *            Output: ""
 *    
 */
Function ValidateAndCleanPhoneNumber ( string Phone )
	// Norwegian phone numbers are exactly 8 digits.
	Phone = regex_replace("[^0-9]", Phone, ""); 
	if ( length (Phone) > 8) then
		Phone = right(Phone, 8); // Strip country code +47
	end if
	if ( length (Phone) < 8) then
		Phone = ""; // Invalid phone number
	end if
	return Phone; 
end

/**
 * Verifies the response from an API call by checking for an error structure in the supplied JSON response.
 * If an error is found, the function throws an exception with the provided error message.
 * If no error is found, it returns `true` indicating the response is valid.
 *
 * @param json $responce The JSON response returned from an API call. It is expected to contain a structure
 *                       that includes an error message if the API call fails.
 *
 * @throws Exception If an error is found in the JSON response, an exception is thrown with the error message.
 *                   The exception message will provide details of the error encountered.
 *
 * @return bool Returns `true` if the API response does not contain an error and is valid. Otherwise, an exception
 *              is thrown.
 *
 * @note This function assumes that the JSON response structure from the API includes a specific error field
 *       containing a message when the API call fails. If the structure is different, the function may not work as expected.
 *
 * @example
 *          - If the response JSON contains an error structure, an exception is thrown with the error message.
 *          - If the response is successful and contains no errors, the function returns `true`.
 */
Function ContaVerifyAPIresponce (json responce)
	array string messages; 
	string msg, keys = list_keys(responce); 
	int er = pos (keys, "errors" ); 
	int me = pos (keys, "messages" ); 
	int i,j;
	if (me<0 && er<0) then
		return true;
	end if
	case
		: (me>=0)
			msg = responce["messages.EN"]; 
			messages[] = msg;
		: (er>=0)
			j = sizeof (responce["errors"]); 
			for (i = 1, j)
				msg = responce[format("errors[%d].messages.EN", i)]; 
				messages[] = string(i)+": "+msg;
			end for
	end case
	throw "Errors: \n" + implode ("\n", messages); 
	// return true; 
end

/**
 * Creates a new customer in the Conta accounting system based on the provided customer primary key.
 * Additionally, the customer ID in Conta is updated in the corresponding customer record in the database.
 * If the customer is successfully created and updated, the function returns "OK".
 *
 * @param string PrimaryKey The primary key of the customer to be created. This key uniquely identifies the customer in the database.
 *
 * @return string Returns "OK" if the customer is created and the customer ID is updated successfully. 
 *                In case of any failure, an error message will be returned.
 *
 * @note This function assumes that all necessary customer data is available in the system and correctly mapped to the 
 *       corresponding fields for Conta customer creation. It also ensures that the customer ID in Conta is updated in the 
 *       corresponding customer record in the database. Error handling should be implemented to address potential failures 
 *       during both the customer creation and update processes.
 *
 * @example 
 *          - If the customer is created and the ID updated successfully, the function will return "OK".
 *          - If there is an issue with customer creation or updating the ID, an appropriate error message may be returned.
 */
Function ContaMakeCustomer(string PrimaryKey)

	array int cuKundeID;
	array string cuKundeNavn, cuAdresse1, cuAdresse2, cuPostNr, cuSted, cuCountry; 
	array string cuLCountry, cuLAdresse1, cuLAdresse2, cuLPostNr, cuLSted, cuMobil, cuEpost; 
	array string cuKundetype, cuOrgNr;
	array string coFirstName, coLastName, coName, coMobile, coEmail;
	array int coID; 
	
	string sql = "SELECT KundeID, KundeNavn, Adresse1, Adresse2, PostNr, Sted, 
	Country, LAdresse1, LAdresse2, LPostNr, LSted, LCountry, Mobil, Epost,
    Kundetype, OrgNr
    FROM Kunder
    WHERE PrimaryKey = :PrimaryKey

    INTO :cuKundeID, :cuKundeNavn, :cuAdresse1, :cuAdresse2, :cuPostNr, :cuSted, :cuCountry, :cuLAdresse1, :cuLAdresse2, :cuLPostNr, :cuLSted, :cuLCountry, :cuMobil, :cuEpost, :cuKundetype, :cuOrgNr
"; 
	string res = ExecuteSQL ( sql ); 
	if ( res != "OK") then
		alert (res); 
	end if
	if ( sizeof ( cuKundeNavn) != 1) then
		throw "Customer not found";
	end if
	string  kundetype = (( lower(cuKundetype[1]) == "priv")?"INDIVIDUAL":"ORGANIZATION"); 
	string phone; 
	JSON cust;
	phone = ValidateAndCleanPhoneNumber (cuMobil[1]); 
	
	// Build the JSON object. 
	cust = JSON(
	    "customerAddressCity", cuSted[1],
	    "customerAddressCountry", cuCountry[1],
	    "customerAddressLine1", cuAdresse1[1],
	    "customerAddressLine2", cuAdresse2[1],
	    "customerAddressPostcode", cuPostNr[1],
	    "customerType", kundetype,
	    "dateOfBirth", "",
	    "daysUntilEstimateOverdue", 14,
	    "daysUntilPaymentReminder", 30,
	    "defaultInvoiceDiscount", "0",
	    "deliveryAddressCity", cuLSted[1],
	    "deliveryAddressCountry", cuLCountry[1],
	    "deliveryAddressLine1", cuLAdresse1[1],
	    "deliveryAddressLine2", cuLAdresse2[1],
	    "deliveryAddressPostcode", cuLPostNr[1],
	   // "efakturaEmailAddress", cuEpost[1],
	   // "efakturaName", cuKundeNavn[1],
	   // "efakturaPhoneNo", phone,
	    "emailAddress", cuEpost[1],
	    "invoiceDeliveryMethod", "EMAIL",
	    "isActive", true,
	    "mailingAddressCity", cuSted[1],
	    "mailingAddressCountry", cuCountry[1],
	    "mailingAddressLine1", cuAdresse1[1],
	    "mailingAddressLine2", cuAdresse2[1],
	    "mailingAddressPostcode", cuPostNr[1],
	    "name", cuKundeNavn[1],
	    "orgNo", cuOrgNr[1],
	    "parentCompanyNameForNuf", "",
	    "phoneNo", phone,
	    "vismaNo", ""
	);
	  
	// Extra..."ehfRecipientOrgNo", cuOrgNr[1],"id", cuKundeID[1],
	
	// Get the Contaxts from the Contacts table. 
	sql = "SELECT FirstName, LastName, Name, Mobile, Email, id
	  FROM Contacts
	  WHERE CustomerFK = :PrimaryKey  AND InvoiceRecipient = 'Yes'

	  INTO :coFirstName, :coLastName, :coName, :coMobile, :coEmail, :coID";
	res = ExecuteSQL ( sql ); 
	if ( res != "OK") then
		alert (res); 
		return res; 
	end if
			
	int i, j; 
	j= sizeof (coFirstName ); 
	print "Contacts="+j;
	
	for (i=1, j)
		phone = ValidateAndCleanPhoneNumber (coMobile[i]); 
		if ( phone != "") then
			cust["contacts[]"] = JSON(
  		  		"id", coID[i],
  			  	"customerId", cuKundeID[1],
 			   	"name", coName[i],
 			   	"phoneNo", phone,
  			  	"emailAddress", coEmail[i],
   			 	"title", ""
			);
		else
			cust["contacts[]"] = JSON(
  		  		"id", coID[i],
  			  	"customerId", cuKundeID[1],
 			   	"name", coName[i],
  			  	"emailAddress", coEmail[i],
   			 	"title", ""
			);
		end if
	end for
	
	// Do the API call
	
	JSON apidata = getContaApiKeyandNumber(); 
	print string(apidata); 
	if ( apidata["APIkey"] == "") then
		alert ("No API key found"); 
		return "ERROR: Missing APIkey"; 
	end if
	
	string APIkey = apidata["APIkey"]; 
	bool production = (apidata["Production"]=="1");
	int compOrg = int(apidata["CompNo"]); 
	
	string hdr = 'apiKey:'+APIkey; 
	string url = getContaBaseURL(production)+"/invoice/organizations/"+compOrg+"/customers";
	print "\n"+url; 
	string data = string(cust); 
	res = HTTP_POST ( url, data, hdr);
	print res;
	
	string contaCustID; 
	// Verify the result- 
	JSON apiRes = res; 
	if (ContaVerifyAPIresponce(apiRes)) then
		contaCustID = apires["id"]; 
		$$CustContaID = contaCustID; 
		print "ContaCustID = " + contaCustID; 
		// Update ContaCustomerID on the customer. 
		sql = "UPDATE Kunder SET ContaCustomerID = :contaCustID, ContaResponce = :res
		WHERE PrimaryKey = :PrimaryKey"; 
		res = ExecuteSQL( sql ); 
		if ( res != "") then
			alert ( res ); 
			return "ERROR Update ContaCustID..."+res; 
		end if
	end if
	return "OK";
End

/**
 * Creates a new product in the Conta accounting system based on the provided product primary key.
 * If the product is successfully created, the function returns "OK".
 *
 * @param string ProdPrimKey The primary key of the product to be created. This key uniquely identifies the product in the database.
 *
 * @return string Returns "OK" if the product is created successfully. If the creation process encounters any issues, 
 *                an error message or code may be returned (depending on the function's implementation).
 *		- The conta-ID for the product is updated on the product. 
 *
 * @note This function assumes that all necessary product data is available in the system and correctly mapped to the 
 *       corresponding fields for Conta product creation. Error handling should be implemented to manage potential failures 
 *       during the product creation process.
 *
 * @example 
 *          - If the product is created successfully, the function will return "OK".
 *          - If there is an issue with the product creation, an appropriate error message may be returned.
 */

Function ContaCreateProduct(string ProdPrimKey)
	array string prodProductNo, prodProductName, prodVatCode, prodBookKepingAccount, prodIsActive;
	array float prodPrice;  
	array int prodContaProductID;
	
	string sql = "SELECT ProductNo, ProductName, VatCode,Price, BookKepingAccount, IsActive, ContaProductID
		FROM Products
		WHERE PrimaryKey = :ProdPrimKey
			
		INTO :prodProductNo, :prodProductName, :prodVatCode, :prodPrice, :prodBookKepingAccount, :prodIsActive, :prodContaProductID
		";
	string res = ExecuteSQL ( sql ) ; 
	if ( sizeof ( prodProductNo) == 0) then 
		throw "Product does not exists, Primarykey " + ProdPrimKey; 
	end if
	
	// Create the JSON object
	int i = 1; 
	bool Active = (prodIsActive[i]=="Yes"); 
	array string ValidVATcodes = {"high", "medium", "low", "zero.rate", "exempted", "export"}; 
	bool b1 = AssertInArray(prodVatCode[i], ValidVATcodes, 
			prodProductName[i] + "ha an invalid VAT code '"+prodVatCode[i]+"', should be: " + implode (",", ValidVATcodes)); 
	string vat = "output."+prodVatCode[i]; 
	JSON prod;
	prod = JSON(
		"bookkeepingAccountNo", prodBookKepingAccount[i],
		"isActive", Active,
		"name", prodProductName[i],
		"price", prodPrice[i],
		"productNo", prodProductNo[i],
		"vatCode", vat
	);
	
	// Do the API request
	JSON apidata = getContaApiKeyandNumber(); 
	if ( apidata["APIkey"] == "") then
		alert ("No API key found"); 
		return "ERROR: Missing APIkey"; 
	end if
	
	string APIkey = apidata["APIkey"]; 
	bool production = (apidata["Production"]=="1");
	int compOrg = int(apidata["CompNo"]); 
	
	string hdr = 'apiKey:'+APIkey; 
	string url = getContaBaseURL(production)+"/invoice/organizations/"+compOrg+"/products";
	print "\n"+url; 
	string data = string(prod); 
	res = HTTP_POST ( url, data, hdr);
	print res;
	int contaProdID;
	// Verify the result- 
	JSON apiRes = res; 
	if (ContaVerifyAPIresponce(apiRes)) then
		contaProdID = int(apires["id"]); 
		print "ContaProductID = " + contaProdID; 
		// Update ContaProductID on the Product. 
		sql = "UPDATE Products SET ContaProductID = :contaProdID
		WHERE PrimaryKey = :ProdPrimKey"; 
		res = ExecuteSQL( sql ); 
		if ( res != "") then
			alert ( res ); 
			return "ERROR Update ContaProductID..."+res; 
		end if
	end if
	return "OK";
End


/**
 * Creates an invoice in the Conta accounting system by pulling data from the order structure in the database 
 * based on the given PrimaryKey. If the invoice has not already been sent (determined by the `allreadysent` flag),
 * the function also adds the recipient structure to ensure the invoice is sent to the customer.
 *
 * @param string OrderPrimaryKey The primary key of the order from which to retrieve the data for the invoice.
 *                                This key uniquely identifies the order in the database.
 * @param bool   allreadysent    A flag indicating whether the invoice has already been sent.
 *                                If `false`, the function will add recipient details and send the invoice to the customer.
 *
 * @return "OK" If everything goes well, otherwise an error message. 
 *              - Creating an invoice in the Conta system.
 *              - Optionally, sending the invoice to the customer if `allreadysent` is `false`.
 *
 * @note This function assumes that the required order data is present in the database, and it will map this data 
 *       to the corresponding fields for the Conta invoice creation process. If the invoice is not sent immediately,
 *       the recipient structure is skipped.
 * @note IF the order has an Invoice-Draft-ID, the draft is deleted on successfull creation. 
 *
 * @example 
 *          - If `allreadysent` is `true`, the invoice will be created without sending it again.
 *          - If `allreadysent` is `false`, the invoice will be created and sent to the customer.
 */
function CreateContaInvoice (string OrderPrimaryKey, bool allreadysent)
	// Verify if the customer is created
	
	string sql, res; 
	bool b1;
	array string aCustPrimKey, aCustContaID; 
	res = ExecuteSQL ("SELECT Kunder.PrimaryKey, Kunder.ContaCustomerID FROM Orders
	LEFT JOIN Kunder ON Kunder.PrimaryKey = Orders.CustomerFK
	WHERE Orders.PrimaryKey = :OrderPrimaryKey
	
	INTO :aCustPrimKey, :aCustContaID");
	case
		: (sizeof (aCustPrimKey) == 0)
			throw ("Order - Customer link broken"); 
		: (aCustContaID[1] == "") 
			res = ContaMakeCustomer(aCustPrimKey[1]); // Save customer first
			b1 = assert ( res, "OK", "Error saving customer to Conta: " + res); 
			aCustContaID[1] = $$CustContaID; // to be included in the API request. 
		default
			// Link is OK, and customer saved, 
	end case
		
	// Verify all the products are saved. 
	array int aContProdID, aContaCount; 
	array string aProdPrimKey; 
	res = ExecuteSQL ( "SELECT pr.ContaProductID, pr.PrimaryKey, count(od.OrderFK) FROM OrdersDetails AS od
			LEFT OUTER JOIN Products AS pr ON pr.PrimaryKey = od.ProductFK
			WHERE od.OrderFK = :OrderPrimaryKey
			GROUP BY pr.ContaProductID, pr.PrimaryKey
			
			INTO :aContProdID, :aProdPrimKey, :aContaCount"); 
	int i, j = sizeof (aContProdID); 
	if (j == 0) then
		throw "No order lines in invoice"; 
	end if
	print "Done checking"+ "\n";  
	for (i=1, j)
		case
			:(aProdPrimKey[i] == "")
				throw Format ("Product not linked, on %d lines.",aContaCount[i]); 
			:(aContProdID[i] == 0)
				res = ContaCreateProduct(aProdPrimKey[i]);
				assert ( res , "OK", "Error saving product " + aProdPrimKey[i] + " " + res); 
		end case
	end for
	// All the products has been saved, conta-id has been updated. 
	
	array string odProductFK, odProductName, odDiscount,
	odTaxType, prPrimaryKey, prProductNo, prProductName, prVatCode, 
	prBookKepingAccount;
	array float odPrice, odQty, odLineTotal, odTaxPercent, odSumInclVAT, prPrice;
	array int prContaProductID, odLineNo;
	
	// Now, pull the Orderdetails data
	sql = "SELECT  od.LineNo, od.ProductFK, od.ProductName, od.Discount, od.TaxType, 
			od.SumInclVAT, pr.PrimaryKey, pr.ProductNo, pr.ProductName, pr.VatCode, pr.BookKepingAccount, 
			od.Price, od.Qty, od.LineTotal, od.TaxPercent, od.SumInclVAT, pr.Price, pr.ContaProductID
  		FROM OrdersDetails AS od
		LEFT JOIN Products AS pr ON pr.PrimaryKey = od.ProductFK
		WHERE od.OrderFK = :OrderPrimaryKey
		
		INTO :odLineNo, :odProductFK, :odProductName, :odDiscount, :odTaxType, :odSumInclVAT, :prPrimaryKey, :prProductNo, :prProductName, :prVatCode, :prBookKepingAccount, :odPrice, :odQty, :odLineTotal, :odTaxPercent, :odSumInclVAT, :prPrice, :prContaProductID
		 ";
	res = ExecuteSQL ( sql ); 
		 
	float sumNetInvoice, sumVATInvoice, sumTotalInvoice, LineVAT, DiscountAM, DiscountPro; 
	int lines = sizeof (odLineNo); 
	array float odDiscountAM, odDiscountPro; 
	// Do Invoice Calculations
	print "Lines = " + lines + "\n"; 
	array string ValidVATcodes = {"high", "medium", "low", "zero.rate", "exempted", "export"}; 

	for (i=1, lines)
		b1 = AssertInArray(prVatCode[i], ValidVATcodes, "Invalid VAT code '"+prVatCode[i]+"', should be: " + implode (",", ValidVATcodes));
		sumNetInvoice += odLineTotal[i];
		LineVAT = odLineTotal[i]*odTaxPercent[i]/100; 
		sumVATInvoice += LineVAT; 
		DiscountAM = DiscountCalc(odQty[i], odPrice[i], odDiscount[i]); 
		odDiscountAM[] = DiscountAM; 
		DiscountPro = (DiscountAM /(odQty[i] * odPrice[i]))*100; 
		odDiscountPro[] = DiscountPro; 
		sumTotalInvoice += odLineTotal[i]+LineVAT; 
	end for
	print "Done calc"+ "\n"; 
	// Then pull the data from the orderhead. 
	array string ohCustomerName, ohOrderDescription, ohOrderStatus, ohYourRef, ohOurRef;
	array date ohOrderDate, ohOrderDeliveryDate, ohInvoiceDate, ohDueDate;
	array float ohSumNet, ohPaidAmount;
	array int ohOrderID, ohContaInvoiceID, ohContaDraftInvoiceID, ohInvoiceNo;
	
	sql = "SELECT CustomerName, OrderDescription, OrderStatus, OrderDate, OrderDeliveryDate, 
			InvoiceDate, DueDate, SumNet, OrderID, ContaInvoiceID, ContaDraftInvoiceID, InvoiceNo, PaidAmount,
			YourRef,OurRef
		FROM Orders
		WHERE PrimaryKey = :OrderPrimaryKey

		INTO  :ohCustomerName, :ohOrderDescription, :ohOrderStatus, :ohOrderDate, :ohOrderDeliveryDate, 
		:ohInvoiceDate, :ohDueDate, :ohSumNet, :ohOrderID, :ohContaInvoiceID, :ohContaDraftInvoiceID, :ohInvoiceNo, :ohPaidAmount, 
		:ohYourRef, :ohOurRef
		";
	res = ExecuteSQL ( sql ); 
	print "\n\nSQL: " + res + "\n\n"; 
	j = sizeof ( ohCustomerName); 
	if ( j == 0 ) then
		throw "Didn't find the order with " + OrderPrimaryKey; 
	end if
	
	// Now, check if we allready have an invoice ID. 
	if ( ohContaInvoiceID[1] != 0) then
		return format ( "Order %d is allready invoiced with number %d, wisit Conta.no to check",ohOrderID[1], ohContaInvoiceID[1]); 
	end if
	
	if (abs(ohSumNet[1] - sumNetInvoice)>0.001) then
		throw format("Invoice calculation does not add up. Head: %.3f, Lines: %.3f", ohSumNet[1], sumNetInvoice); 
	end if
	
	print "Done checking, j="+j+ "\n"; 
	// Now, lets create the JSON nessessary for the API. 
	ohYourRef[1] =  ((ohYourRef[1] == "")?ohCustomerName[1]:ohYourRef[1]);
	JSON order; 
	order = JSON(
	    "customerId", aCustContaID[1],
	    "customerReference", ohYourRef[1],
	    // "attachmentFileId", "9223372036854776000",
	    // "customerGroupId", "9223372036854776000",
	    // "departmentId", "9223372036854776000",
	    "exchangeRate", 1,
	    "exchangeRateReferenceDate", string(ohInvoiceDate[1], "%Y-%m-%d"),
	    "invoiceCurrency", "NOK",
	    "invoiceLanguage", "NO",
		"isCreatedInOtherSystem", allreadysent, 
		"invoiceDate", string(ohInvoiceDate[1], "%Y-%m-%d"),
		"invoiceDueDate", string(ohDueDate[1], "%Y-%m-%d"),
	    "personalMessage", ohOrderDescription[1],
	    // "projectId", "9223372036854776000",
	    // "registrationSource", "CONTA",
	    // "saleId", "9223372036854776000",
	    "type", "NORMAL"
	);
	string extraSQL; 
	if (ohContaDraftInvoiceID[1] != 0 ) then
		order["id"] = ohContaDraftInvoiceID[1]; 
		extraSQL = ", ContaDraftInvoiceID = ''";
	end if
	print "Done OH"+ "\n"; 
	string vat;
	for (i=1, lines)
		vat = prVatCode[i]; 
		order["invoiceLines[]"] = JSON(
		    "description", odProductName[i],
		    "discount", odDiscountPro[i],
		    "lineNo", odLineNo[i],
		    "price", odPrice[i],
		    "productId", prContaProductID[i],
		    "quantity", odQty[i],
		    "sumDiscount", odDiscountAM[i], // or calculated if discount is a percentage
		    "sumNet", odLineTotal[i],
		    "vatCode", vat
			);
	end for
	
	JSON apidata = getContaApiKeyandNumber(); 
	if ( apidata["APIkey"] == "") then
		alert ("No API key found"); 
		return "ERROR: Missing APIkey"; 
	end if
	string InvoEmailSub = apidata["EmailSubject"];
	string InvoEmailCont = apidata["EmailContent"];
	
	// Add the invoice recipients
	array string coFirstName, coLastName, coName, coMobile, coEmail;
	array string cuKundeNavn, cuAdresse1, cuAdresse2, cuPostNr, cuSted, cuCountry; 
	array string cuMobil, cuEpost; 
	string MyCompany = ExecuteSQL ( "SELECT CompanyName FROM Preferences"); 
	array int coID; 
	string CustomerPrimKey = aCustPrimKey[1]; 
	// Get the Contaxts from the Contacts table. 
	if ( ! allreadysent ) then
		print "\nEmail-recipients...\n";
		sql = "SELECT FirstName, LastName, Name, Mobile, Email, id
		  FROM Contacts
		  WHERE CustomerFK = :CustomerPrimKey  AND InvoiceRecipient = 'Yes'

		  INTO :coFirstName, :coLastName, :coName, :coMobile, :coEmail, :coID";
		res = ExecuteSQL ( sql ); 
		if ( res != "OK") then
			alert (res); 
			return res; 
		end if
	
		j= sizeof (coFirstName); 
		if (j == 0) then
			sql = "SELECT  KundeNavn, Adresse1, Adresse2, PostNr, Sted, 
				Country, Mobil, Epost
			    FROM Kunder
			    WHERE PrimaryKey = :CustomerPrimKey

			    INTO :cuKundeNavn, :cuAdresse1, :cuAdresse2, :cuPostNr, :cuSted, :cuCountry, :cuMobil, :cuEpost
			"; 
			res = executeSQL ( sql ) ; 
			if ( sizeof ( cuKundeNavn) == 0) then
				return "No email registered on the customer, add a email to send it"; 
			end if
			// Create E-mail recipients from the fields on the customer. 
			order["invoiceRecipients[]"] = JSON(
			"customerId",aCustContaID[1],
			// "ehfRecipient","IeNenkUZHGUor6TcgV7iZZYML3mwDl35Mk-708RCcf-k Na4jQ",
			"emailAddress",cuEpost[1],
			"emailContent",InvoEmailCont, // Here we must have some content preferences
			"emailRecipientType","EMAIL_TO",
			"emailSubject", InvoEmailSub,
			"includeDefaultAttachment",true,
			"includeInvoiceAttachment",true,
			"includeInvoiceInfo",true,
			/*"mailAddressCity","string",
			"mailAddressCountryCode","st",
			"mailAddressLine1","string",
			"mailAddressLine2","string",
			"mailAddressPostcode","string",*/
			"name",cuKundeNavn[1],
			"phoneNo",cuMobil[1],
			"type","EMAIL");
		else
			for (i=1, j)
				order["invoiceRecipients[]"] = JSON(
				"customerId",aCustContaID[1],
				// "ehfRecipient","IeNenkUZHGUor6TcgV7iZZYML3mwDl35Mk-708RCcf-k Na4jQ",
				"emailAddress",coEmail[i],
				"emailContent",InvoEmailCont, // Here we must have some content preferences
				"emailRecipientType","EMAIL_TO",
				"emailSubject", InvoEmailSub,
				"includeDefaultAttachment",true,
				"includeInvoiceAttachment",true,
				"includeInvoiceInfo",true,
				/*"mailAddressCity","string",
				"mailAddressCountryCode","st",
				"mailAddressLine1","string",
				"mailAddressLine2","string",
				"mailAddressPostcode","string",*/
				"name",coName[i],
				"phoneNo",coMobile[i],
				"type","EMAIL");
			end for
		end if
	end if
	print string(order); 
	
	
	// Do the API request
	
	
	string APIkey = apidata["APIkey"]; 
	bool production = (apidata["Production"]=="1");
	int compOrg = int(apidata["CompNo"]); 
	
	string hdr = 'apiKey:'+APIkey; 
	// /invoice/organizations/{opContextOrgId}/invoices
	string url = getContaBaseURL(production)+"/invoice/organizations/"+compOrg+"/invoices";
	print "\n"+url; 
	string data = string(order); 
	res = HTTP_POST ( url, data, hdr);
	print "\n"+res;
	int contaInvID, contaInvNo;
	string status; 
	// Verify the result- 
	JSON apiRes = res; 
	if (ContaVerifyAPIresponce(apiRes)) then
		contaInvID = int(apires["id"]); 
		contaInvNo = int(apires["invoiceNo"]); 
		status = apires["status"];
		print "\nContaInvoiceID = " + contaInvID+"\n"; 
		// Update ContaProductID on the Product. 
		// ExtraSQL contains nulling og draft-ID, if previously sent as draft. 
		sql = "UPDATE Orders SET ContaInvoiceID = :contaInvID, InvoiceNo = :contaInvNo, OrderStatus = :status"+extraSQL+"
		WHERE PrimaryKey = :OrderPrimaryKey"; 
		res = ExecuteSQL( sql ); 
		if ( res != "") then
			alert ( res ); 
			return "ERROR Update ContaInvoiceID..."+res; 
		end if
	end if
	
	
	return "OK"; 
end

/**
 * Creates a draft invoice in the Conta accounting system for the order with the specified PrimaryKey.
 * The draft invoice can be edited in the Conta web-interface before being finalized.
 * The function retrieves order details from the database and creates a draft invoice in Conta, without 
 * sending it to the customer. This allows for review and edits prior to finalizing the invoice.
 *
 * @param string OrderPrimaryKey The unique primary key of the order for which the draft invoice is created.
 *                               The order details are retrieved from the database using this key.
 *
 * @return string Returns "OK" if the draft invoice was successfully created in the Conta system,
 *                or an error message if the creation fails.
 *
 * @note This function does not send the invoice to the customer. It only creates a draft that can be 
 *       reviewed and edited in the Conta web interface before finalization.
 * @note IF the invoice is created from the CreateContaInvoice, the draft is deleted. 
 *
 * @example
 *          - Input: "ORD12345"
 *            Output: "OK"
 */
function CreateInvoiceDraft (string OrderPrimaryKey)
	// Verify if the customer is created
	
	string sql, res; 
	bool b1;
	array string aCustPrimKey, aCustContaID; 
	res = ExecuteSQL ("SELECT Kunder.PrimaryKey, Kunder.ContaCustomerID FROM Orders
	LEFT JOIN Kunder ON Kunder.PrimaryKey = Orders.CustomerFK
	WHERE Orders.PrimaryKey = :OrderPrimaryKey
	
	INTO :aCustPrimKey, :aCustContaID");
	case
		: (sizeof (aCustPrimKey) == 0)
			throw ("Order - Customer link broken"); 
		: (aCustContaID[1] == "") 
			res = ContaMakeCustomer(aCustPrimKey[1]); // Save customer first
			b1 = assert ( res, "OK", "Error saving customer to Conta: " + res); 
			aCustContaID[1] = $$CustContaID; // to be included in the API request. 
		default
			// Link is OK, and customer saved, 
	end case
		
	// Verify all the products are saved. 
	array int aContProdID, aContaCount; 
	array string aProdPrimKey; 
	res = ExecuteSQL ( "SELECT pr.ContaProductID, pr.PrimaryKey, count(od.OrderFK) FROM OrdersDetails AS od
			LEFT OUTER JOIN Products AS pr ON pr.PrimaryKey = od.ProductFK
			WHERE od.OrderFK = :OrderPrimaryKey
			GROUP BY pr.ContaProductID, pr.PrimaryKey
			
			INTO :aContProdID, :aProdPrimKey, :aContaCount"); 
	int i, j = sizeof (aContProdID); 
	if (j == 0) then
		throw "No order lines in invoice"; 
	end if
	print "Done checking"+ "\n";  
	for (i=1, j)
		case
			:(aProdPrimKey[i] == "")
				throw Format ("Product not linked, on %d lines.",aContaCount[i]); 
			:(aContProdID[i] == 0)
				res = ContaCreateProduct(aProdPrimKey[i]);
				assert ( res , "OK", "Error saving product " + aProdPrimKey[i] + " " + res); 
		end case
	end for
	// All the products has been saved, conta-id has been updated. 
	
	array string odProductFK, odProductName, odDiscount,
	odTaxType, prPrimaryKey, prProductNo, prProductName, prVatCode, 
	prBookKepingAccount;
	array float odPrice, odQty, odLineTotal, odTaxPercent, odSumInclVAT, prPrice;
	array int prContaProductID, odLineNo;
	
	// Now, pull the Orderdetails data
	sql = "SELECT  od.LineNo, od.ProductFK, od.ProductName, od.Discount, od.TaxType, 
			od.SumInclVAT, pr.PrimaryKey, pr.ProductNo, pr.ProductName, pr.VatCode, pr.BookKepingAccount, 
			od.Price, od.Qty, od.LineTotal, od.TaxPercent, od.SumInclVAT, pr.Price, pr.ContaProductID
  		FROM OrdersDetails AS od
		LEFT JOIN Products AS pr ON pr.PrimaryKey = od.ProductFK
		WHERE od.OrderFK = :OrderPrimaryKey
		
		INTO :odLineNo, :odProductFK, :odProductName, :odDiscount, :odTaxType, :odSumInclVAT, :prPrimaryKey, :prProductNo, :prProductName, :prVatCode, :prBookKepingAccount, :odPrice, :odQty, :odLineTotal, :odTaxPercent, :odSumInclVAT, :prPrice, :prContaProductID
		 ";
	res = ExecuteSQL ( sql ); 
		 
	float sumNetInvoice, sumVATInvoice, sumTotalInvoice, LineVAT, DiscountAM, DiscountPro; 
	int lines = sizeof (odLineNo); 
	array float odDiscountAM, odDiscountPro; 
	// Do Invoice Calculations
	array string ValidVATcodes = {"high", "medium", "low", "zero.rate", "exempted", "export"}; 
	print "Lines = " + lines + "\n"; 
	for (i=1, lines)
		b1 = AssertInArray(prVatCode[i], ValidVATcodes, "Invalid VAT code '"+prVatCode[i]+"', should be: " + implode (",", ValidVATcodes));
		sumNetInvoice += odLineTotal[i];
		LineVAT = odLineTotal[i]*odTaxPercent[i]/100; 
		sumVATInvoice += LineVAT; 
		DiscountAM = DiscountCalc(odQty[i], odPrice[i], odDiscount[i]); 
		odDiscountAM[] = DiscountAM; 
		DiscountPro = (DiscountAM /(odQty[i] * odPrice[i]))*100; 
		odDiscountPro[] = DiscountPro; 
		sumTotalInvoice += odLineTotal[i]+LineVAT; 
	end for
	print "Done calc"+ "\n"; 
	// Then pull the data from the orderhead. 
	array string ohCustomerName, ohOrderDescription, ohOrderStatus;
	array date ohOrderDate, ohOrderDeliveryDate, ohInvoiceDate, ohDueDate;
	array float ohSumNet;
	array int ohOrderID, ohContaInvoiceID;
	
	sql = "SELECT CustomerName, OrderDescription, OrderStatus, OrderDate, OrderDeliveryDate, 
			InvoiceDate, DueDate, SumNet, OrderID, ContaDraftInvoiceID
		FROM Orders
		WHERE PrimaryKey = :OrderPrimaryKey

		INTO  :ohCustomerName, :ohOrderDescription, :ohOrderStatus, :ohOrderDate, :ohOrderDeliveryDate, :ohInvoiceDate, :ohDueDate, :ohSumNet, :ohOrderID, :ohContaInvoiceID
		";
	res = ExecuteSQL ( sql ); 
	
	j = sizeof ( ohCustomerName); 
	if ( j == 0 ) then
		throw "Didn't find the order with " + OrderPrimaryKey; 
	end if
	
	// Now, check if we allready have an invoice ID. 
	if ( ohContaInvoiceID[1] != 0) then
		return format ( "Order %d is allready made draft with number %d, wisit Conta.no to check",ohOrderID[1], ohContaInvoiceID[1]); 
	end if
	
	if (abs(ohSumNet[1] - sumNetInvoice)>0.001) then
		throw format("Invoice calculation does not add up. Head: %.3f, Lines: %.3f", ohSumNet[1], sumNetInvoice); 
	end if
	
	print "Done checking, j="+j+ "\n"; 
	// Now, lets create the JSON nessessary for the API. 
	JSON order; 
	order = JSON(
	    "customerId", aCustContaID[1],
	    "customerReference", ohCustomerName[1],
	    // "attachmentFileId", "9223372036854776000",
	    // "customerGroupId", "9223372036854776000",
	    // "departmentId", "9223372036854776000",
	    "exchangeRate", 1,
	    "exchangeRateReferenceDate", string(ohInvoiceDate[1], "%Y-%m-%d"),
	    "invoiceCurrency", "NOK",
	    "invoiceLanguage", "NO",
	    "personalMessage", ohOrderDescription[1],
	    // "projectId", "9223372036854776000",
	    "registrationSource", "CONTA",
	    // "saleId", "9223372036854776000",
	    // Not for drafts: "sumNet", ohSumNet[1],
	    // "sumRemaining", "99999999999", // not sure what this is?
	    // Not for drafts: "sumTotal", sumTotalInvoice,
	    // Not for drafts: "sumVAT", sumVATInvoice,
	    "type", "NORMAL"
	);
	print "Done OH"+ "\n"; 
	string vat;
	for (i=1, lines)
		vat = prVatCode[i]; 
		order["invoiceDraftLines[]"] = JSON(
		    // Not for drafts: "bookkeepingAccountNo", prBookKepingAccount[i],
		    "description", odProductName[i],
		    "discount", odDiscountPro[i],
		    // "id", "9223372036854776000",
		    // "invoiceDraftId", "9223372036854776000",
		    "lineNo", odLineNo[i],
		    "price", odPrice[i],
		    "productId", prContaProductID[i],
		    "quantity", odQty[i],
		    "sumDiscount", odDiscountAM[i], // or calculated if discount is a percentage
		    "sumNet", odLineTotal[i],
		    "vatCode", vat
		    //"vatId", "9223372036854776000"
			);
	end for
	print string(order); 
	
	// Do the API request
	JSON apidata = getContaApiKeyandNumber(); 
	if ( apidata["APIkey"] == "") then
		alert ("No API key found"); 
		return "ERROR: Missing APIkey"; 
	end if
	
	string APIkey = apidata["APIkey"]; 
	bool production = (apidata["Production"]=="1");
	int compOrg = int(apidata["CompNo"]); 
	
	string hdr = 'apiKey:'+APIkey; 
	// /invoice/organizations/{opContextOrgId}/invoice-drafts
	string url = getContaBaseURL(production)+"/invoice/organizations/"+compOrg+"/invoice-drafts";
	print "\n"+url; 
	string data = string(order); 
	res = HTTP_POST ( url, data, hdr);
	print "\n"+res;
	int contaInvID;
	// Verify the result- 
	JSON apiRes = res; 
	if (ContaVerifyAPIresponce(apiRes)) then
		contaInvID = int(apires["id"]); 
		print "\nContaInvoiceID = " + contaInvID+"\n"; 
		// Update ContaProductID on the Product. 
		sql = "UPDATE Orders SET ContaDraftInvoiceID = :contaInvID
		WHERE PrimaryKey = :OrderPrimaryKey"; 
		res = ExecuteSQL( sql ); 
		if ( res != "") then
			alert ( res ); 
			return "ERROR Update ContaInvoiceID..."+res; 
		end if
	end if
	
	
	return "OK"; 
end
/**
 * Retrieves the invoice number and invoice status for a given order and updates the corresponding record in the database.
 * This function makes an API call to the Conta accounting system to fetch the invoice details and updates the
 * order record in the database with the retrieved information.
 *
 * @param string PrimaryKeyOrder The unique primary key of the order for which the invoice details are retrieved.
 *                               The order record in the database is updated with the invoice number and status.
 *
 * @return string Returns "OK" if the invoice details were successfully retrieved and the database was updated,
 *                or an error message if the update fails.
 *
 * @note This function assumes that the order already has an associated invoice in Conta. It will update the
 *       order record with the invoice number and the latest status.
 *
 * @example
 *          - Input: "ORD12345"
 *            Output: "OK"
 */
function UpdateOrderContaInvoice (string PrimaryKeyOrder)
	array int ohContaInvoiceID, ohContaDraftInvoiceID,ohInvoiceNo;
	array float ohPaidAmount;
	string sql = "SELECT InvoiceNo, PaidAmount, ContaInvoiceID, ContaDraftInvoiceID FROM Orders
	WHERE PrimaryKey = :PrimaryKeyOrder
	INTO :ohInvoiceNo, :ohPaidAmount, :ohContaInvoiceID, :ohContaDraftInvoiceID
	";
	string res = ExecuteSQL ( sql ); 
	case 
		: (res != "OK")
			return "Some Error returned from SQL: " + res; 
		:(sizeof (ohContaInvoiceID) == 0)
			return "Order not found: " + res; 
		:(ohContaInvoiceID[1] == 0 && ohContaDraftInvoiceID[1] == 0)
			return "Order not invoice yet";
		:(ohContaInvoiceID[1] == 0 && ohContaDraftInvoiceID[1] != 0)
			return "Order only have draft, no Invoice number yet";
		default
	end case
	
	
	// Do the API request
	JSON apidata = getContaApiKeyandNumber(); 
	if ( apidata["APIkey"] == "") then
		alert ("No API key found"); 
		return "ERROR: Missing APIkey"; 
	end if
	
	string APIkey = apidata["APIkey"]; 
	bool production = (apidata["Production"]=="1");
	int compOrg = int(apidata["CompNo"]); 
	
	string hdr = 'apiKey:'+APIkey; 
	// /invoice/organizations/{opContextOrgId}/invoices/{id}
	string url = getContaBaseURL(production)+"/invoice/organizations/"+compOrg+"/invoices/"+ohContaInvoiceID[1];
	print "\n"+url+"\n"; 
	
	res = HTTP_GET ( url, hdr);
	print "\n"+res;
	int contaInvNo;
	string status; 
	// Verify the result- 
	JSON apiRes = res; 
	if (ContaVerifyAPIresponce(apiRes)) then
		contaInvNo = int(apires["invoiceNo"]); 
		status = apires["status"];
		print "\ncontaInvNo = " + contaInvNo+"\n"; 
		// Update ContaProductID on the Product. 
		sql = "UPDATE Orders SET InvoiceNo = :contaInvNo, OrderStatus = :status
		WHERE PrimaryKey = :PrimaryKeyOrder"; 
		res = ExecuteSQL( sql ); 
		if ( res != "") then
			alert ( res ); 
			return "ERROR Update ContaInvoiceID..."+res; 
		end if
	end if
		
	
	return "OK"; 
end

/**
 * Adds a new contact record linked to the specified customer.
 * This utility function is designed for the GUI and allows the creation of a new contact 
 * that is associated with an existing customer in the system.
 *
 * @param string $CustomerPriKey The unique primary key of the customer to which the new contact will be linked.
 *                               The contact record will be added and associated with this customer.
 *
 * @return string Returns "" if the contact was successfully added, or an error message if the operation fails.
 *
 * @note This function is intended for GUI use and will add a new contact record to the system, linking it
 *       to the provided customer. It is not an API-based function.
 *
 * @example
 *          - Input: "CUST12345"
 *            Output: ""
 */
function CustomerAddContact (string CustomerPriKey)
	string FirstName = "New Contact"; 
	string sql = "INSERT INTO Contacts (CustomerFK, FirstName) VALUES (:CustomerPriKey, :FirstName)"; 
	string res = ExecuteSQL( sql ) ; 
	return res; 
end
